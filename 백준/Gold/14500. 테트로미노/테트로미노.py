N, M = map(int, input().split()) 
arr = [list(map(int, input().split())) for _ in range(N)]  

# 테트로미노의 회전 및 대칭을 고려한 상대적 좌표 리스트를 저장
tet=[[(0,1), (0,2), (0,3)],[(1,0), (2,0), (3,0)],  # ㅣ자 모양 (회전)
    [(0,1), (1,0), (1,1)],  # ㅁ자 모양
    [(1,0), (2,0), (2,1)], [(0,1), (0,2), (1,0)],  # ㄴ자 모양 (회전)
    [(0,1), (1,1), (2,1)], [(0,1), (0,2),(-1,2)],  # ㄴ자 모양 (회전)
    [(0,1),(-1,1),(-2,1)], [(1,0), (1,1), (1,2)],  # ㄴ자 대칭 (회전)
    [(0,1), (1,0), (2,0)], [(0,1), (0,2), (1,2)],  # ㄴ자 대칭 (회전)
    [(1,0), (1,1), (2,1)], [(0,1),(-1,1),(-1,2)],  # ㄹ자 모양 (회전)
    [(1,0), (0,1),(-1,1)], [(0,1), (1,1), (1,2)],  # ㄹ자 대칭 (회전)
    [(0,1), (0,2), (1,1)], [(-1,1),(0,1), (1,1)],  # ㅏ자 모양 (회전)
    [(0,1), (0,2),(-1,1)], [(1,0), (2,0), (1,1)]]  # ㅏ자 모양 (회전)

# 테트로미노가 놓인 위치의 값 합계를 계산하는 함수
def cal(i, j, pos):
    sm = arr[i][j]  # 기준값(현재 위치의 값)을 저장
    for di, dj in pos:  # 테트로미노의 상대적 좌표를 적용
        ni, nj = i + di, j + dj  # 새로운 좌표 계산
        if 0 <= ni < N and 0 <= nj < M:  # 새로운 좌표가 격자 범위 내에 있을 경우
            sm += arr[ni][nj]  # 그 칸의 값을 더함
        else:
            return 0  # 범위를 벗어나면 0을 반환
    return sm  # 값의 합계를 반환

# 최댓값을 저장할 변수
ans = 0  
for i in range(N): 
    for j in range(M):
        # 각 칸에서 가능한 모든 테트로미노 패턴을 적용
        for pos in tet: 
            # 테트로미노 패턴에 대한 값의 합 계산
            sm = cal(i, j, pos)  
            ans = max(ans, sm)  # 최대값 갱신

print(ans)  # 최대값 출력

